#ifndef PART_2_THREADS_H
#define PART_2_THREADS_H

#define SIZE 26
#define PERM 0644

/**
 * Данный массив
 */
volatile char array[SIZE];

/**
 * структура для хранения времени
 */
struct time_threads {
    unsigned long time_main;
    unsigned long time_change;
    unsigned long time_reverse;
    unsigned long count_letter;
};

/**
 * вывод массива в stdin
 */
void print_array();

/**
 * Функция для разбора ключей
 * @param argc - аргументы командной строки
 * @param argv - аргументы командной строки
 * @return
 */
void parse_flag(int argc, char *argv[]);

/**
 * Функция для запуска: заполняет массив, вызывает функцию для начала работы
 * @param argc - аргументы командной строки
 * @param argv - аргументы командной строки
 */
void start(int argc, char *argv[]);

/**
 * Функция, выполняющая первое подзадание.
 * Основной поток раз в секунду поочерёдно пробуждает один из потоков и дожидается конца его работы, после чего выводит
 * полученный массив на стандартный вывод. Для реализации синхронизации необходимо использовать sem_init(3RT),
 * sem_post(3RT), sem_wait(3RT).
 */
void first_task();

/**
 * Функция, выполняющая второе подзадание.
 * Основной поток раз в секунду поочерёдно пробуждает один из потоков и дожидается конца его работы, после чего выводит
 * полученный массив на стандартный вывод. Для реализации синхронизации необходимо использовать
 * semget(2), semop(2), semctl(2).
 */
void second_task();

/**
 * Функция для 3-его задания
 * Основной поток раз в указанное количество микросекунд выводит массив на стандартный вывод.
 * Подпотоки раз в указанное количество микросекунд выполняют своё действие, блокируя на время своей работы доступ
 * к общему ресурсу. Для блокировки использовать pthread_mutex_init(3C), pthread_mutex_lock(3C),
 * pthread_mutex_unlock(3C).
 */
void third_task();

/**
 * Функция для 4-го подзадания
 * Основной поток раз в указанное количество микросекунд выводит массив на стандартный вывод. Подпотоки раз в
 * указанное количество микросекунд выполняют своё действие. Еще один подпоток должен раз в указанное количество
 * микросекунд выводить количество заглавных символов в массиве на стандартный вывод. Потоки, не изменяющие массив
 * могут выполняться параллельно, но должны блокировать изменение на время работы. Для блокировки использовать
 * pthread_rwlock_init(3C), pthread_rwlock_rdlock(3C), pthread_rwlock_wrlock(3C), pthread_rwlock_unlock(3C).
 */
void forth_task();

/**
 * Функция для смены регистра
 */
void change_reg();

/**
 * Функция, которая разворачивает массив
 */
void reverse();

/**
 * функция считает количество заглавных символов
 * @return количество заглавных символов
 */
unsigned short count_letters();

/**
 * Функция проверки errno
 * @param strerr - строка, выводящаяся в случае ошибки
 */
void check_errno(char* strerr);

/**
 * поток 1 для 4 подзадания
 */
void *task1_thread1();


/**
 * поток 2 для 4 подзадания
 */
void *task1_thread2();


/**
 * поток 1 для 5 подзадания
 */
void *task2_thread1();


/**
 * поток 2 для 5 подзадания
 */
void *task2_thread2();


/**
 * поток 2 для 6 подзадания
 */
void *task3_thread1();

/**
 * поток 2 для 6 подзадания
 */
void *task3_thread2();


/**
 * поток 2 для 7 подзадания
 */
void *task4_thread1();

/**
 * поток 2 для 7 подзадания
 */
void *task4_thread2();


/**
 * поток 3 для 7 подзадания
 */
void *task4_thread3();
#endif //PART_2_THREADS_H
